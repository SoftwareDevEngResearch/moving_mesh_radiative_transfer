#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Wed Jan 26 07:24:05 2022@author: William Bennett"""import numpy as npfrom numba import int64, float64from numba.experimental import jitclassimport quadpy# from main import IC_func from mesh import meshfrom functions import normPnfrom mutables import IC_func###############################################################################data = [('N_ang', int64),         ('N_space', int64),        ('M', int64),        ('tfinal', float64),        ('sigma_t', float64[:]),        ('sigma_s', float64[:]),                ]# @jitclass    # @jitclass(data)class build:    def __init__(self, N_ang, N_space, M, tfinal, x0, sigma_t, sigma_s, source, uncollided, moving, time, plotting):        self.N_ang = N_ang        self.N_space = N_space        self.M = M        self.tfinal = tfinal        self.sigma_t = sigma_t        self.sigma_s = sigma_s        self.IC = np.zeros((N_ang, N_space, M+1))        self.mus = quadpy.c1.gauss_lobatto(N_ang).points        self.ws = quadpy.c1.gauss_lobatto(N_ang).weights        self.xs_quad = quadpy.c1.gauss_lobatto(M).points        self.ws_quad = quadpy.c1.gauss_lobatto(M).weights        self.x0 = x0        self.source = source        self.uncollided = uncollided         self.moving = moving                def integrate_quad(self, a, b, ang, space, j, ic):        self.IC[ang,space,j] = (b-a)/2 * np.sum(self.ws_quad * ic.function((b-a)/2*self.xs_quad + (a+b)/2) * normPn(j, self.xs_quad, -1.0, 1.0))                    def make_IC(self):        edges = mesh(self.N_space, self.x0, self.source, self.tfinal, self.uncollided, self.moving)        edges_init = edges.edges        ic = IC_func(self.source, self.uncollided)        for ang in range(self.N_ang):            for space in range(self.N_space):                for j in range(self.M):                    self.integrate_quad(edges_init[space], edges_init[space+1], ang, space, j, ic)                                            